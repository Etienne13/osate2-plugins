-- Copyright (c) 2011, Rockwell Collins.
-- Developed with the sponsorship of the Defense Advanced Research
-- Projects Agency (DARPA).

-- Permission is hereby granted, free of charge, to any person
-- obtaining a copy of this data, including any software or models
-- in source or binary form, as well as any drawings,
-- specifications, and documentation (collectively "the Data"), to
-- deal in the Data without restriction, including without
-- limitation the rights to use, copy, modify, merge, publish,
-- distribute, sublicense, and/or sell copies of the Data, and to
-- permit persons to whom the Data is furnished to do so, subject to
-- the following conditions:

-- The above copyright notice and this permission notice shall be
-- included in all copies or substantial portions of the Data.

-- THE DATA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS, SPONSORS,
-- DEVELOPERS, CONTRIBUTORS, OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-- CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
-- CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
-- CONNECTION WITH THE DATA OR THE USE OR OTHER DEALINGS IN THE
-- DATA.

PALS_Threads := {t in Thread_Set | Property_Exists(t, "PALS_Properties::PALS_Id")};

PALS_Period(t) := Property(t, "PALS_Properties::PALS_Period");
PALS_Id(t) := Property(t, "PALS_Properties::PALS_Id");
PALS_Group(t) := {s in PALS_Threads | PALS_Id(t) = PALS_Id(s)};
Output_Delay(t) := Property(t, "META_Properties::Output_Delay");

Max_Thread_Jitter(Threads) :=
  Max({Property(p, "Clock_Jitter") for p in Processor_Set |
       Cardinal({t in Threads | Is_Bound_To(t, p)}) > 0});

Connections_Among(Set) :=
  {c in Connection_Set | Member(Owner(Source(c)), Set) and
                         Member(Owner(Destination(c)), Set)};

theorem PALS_Period_is_Period
  foreach s in PALS_Threads do
    check Property_Exists(s, "Period") and
          PALS_Period(s) = Property(s, "Period");
end;

theorem PALS_Group_shares_PALS_Period
  foreach s in PALS_Threads do
  foreach t in PALS_Group(s) do
    check PALS_Period(s) = PALS_Period(t);
end;

theorem PALS_Causality
  foreach s in PALS_Threads do
    PALS_Group := PALS_Group(s);
    Clock_Jitter := Max_Thread_Jitter(PALS_Group);
    Min_Latency := Min({Lower(Property(c, "Latency")) for
                        c in Connections_Among(PALS_Group)});
    Min_Output_Delay := Min({Output_Delay(t) for t in PALS_Group});
    check (if 2 * Clock_Jitter > Min_Latency then
             Min_Output_Delay > 2 * Clock_Jitter - Min_Latency
           else
             true);
end;

theorem PALS_Period
  foreach s in PALS_Threads do
    PALS_Group := PALS_Group(s);
    Clock_Jitter := Max_Thread_Jitter(PALS_Group);
    Max_Latency := Max({Upper(Property(c, "Latency"))
                        for c in Connections_Among(PALS_Group)});
    Deadline := Property(s, "Deadline");
    PALS_Period := PALS_Period(s);
    check (Deadline < PALS_Period - 2 * Clock_Jitter - Max_Latency);
end;

Empty(s) := Cardinal(s) = 0;
Not_Collocated := "META_Properties::Not_Collocated";

theorem Not_Collocated
  foreach s1 in {s in System_Set | Property_Exists(s, Not_Collocated)} do
  foreach s2 in Property(s1, Not_Collocated) do
  foreach t1 in {t in Thread_Set | Is_Subcomponent_Of(t, s1)} do
  foreach t2 in {t in Thread_Set | Is_Subcomponent_Of(t, s2)} do
    check Empty({p in Processor_Set | Is_Bound_To(t1, p) and Is_Bound_To(t2, p)});
end;
